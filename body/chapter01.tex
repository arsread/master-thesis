%%==========================
%% chapter01.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% version: 0.3a
%% Encoding: UTF-8
%% last update: Dec 5th, 2010
%%==================================================

%\bibliographystyle{sjtu2} %[此处用于每章都生产参考文献]
\chapter{绪论}
\label{chap:Intorduction}

程序分析是近年来的热门话题，而其中利用工具搜集和分析程序动态运行时的信息的技术也被广泛采用。另一方面，随着计算机硬件的发展，多核、分布式技术的适用范围和效率也越来越高，并行程序的重要性也逐渐凸显。本文结合了动态程序分析的特点，将动态程序分析与并行化结合起来，提出并开发了一个适用于编写并行的动态分析程序的框架，并通过实验证明了该框架的实用性和效率。

\section{研究背景}

近年来，随着编程技术和研究的深入，越来越多的语言特性被编程者们所开发和采用，多态、反射、动态加载等技术的使用也越来越广泛。而这些技术对采用对传统的静态编译和分析提出了挑战。污点分析\cite{taint01,taint02}和符号执行\cite{symbExec}等静态分析的方法由于分析效率较低，加之难以收集程序动态运行时的一些信息，其局限性逐渐凸显。为了解决这些问题，动态分析的技术被引入。顾名思义，动态分析即是在运行被分析程序的状态下运行分析程序，从而能够有效地减少分析规模，提高分析精度，并能收集动态信息。一些静态分析技术如程序切片\cite{dynSlc}和符号执行\cite{dynSym}也相应地加入了动态分析的内容。

动态程序的分析有效地减少了相对分析时间，但实际在面对重量级分析的时候，整个分析过程所消耗的时间依然很多，尤其是面对一些本身比较庞大、复杂的程序，在算法已经经过优化的情况下仍旧不能有效地提高运行效率的时候，每个测试用例或者被分析程序动辄需要运行几个小时乃至几天，给程序的分析、查错和优化带了了很大的不便。基于该问题，研究者们采取了不同的解决方案。除了在分析方法本身进行改进分析和在算法的效率以及复杂度上作提高之外，也有另一些方案针对分析程序的执行作加速，其中就包括了并行化的方法。

\section{并行程序分析}

并行化是基于多核、分布式技术等多种硬件技术的发明及成熟而发展起来的技术。在传统的串行计算中，指令是顺序串行执行的，即便后续指令没有用到之前的指令的结果，也只能进行等待，造成了时间上的浪费。并行的理念就是将这些并行度大的指令或者任务派发给空闲的计算资源如cpu核心、物理机等进行分开处理，从而提高计算效率。

在动态程序分析方面，有一些程序所采用的的分析内容也具有这种并行性。这些分析程序只是从所运行的被分析程序处取得相关的运行信息，然后进行处理。这些分析程序一般没有返回值，或者不需要写回被分析的程序。换言之，这些分析程序对被分析程序基本没有影响。一个简单的例子就是函数计数。函数计数旨在计算程序动态运行时一共执行了多少函数，进一步拓展还可以分析每个函数各执行了多少次，每次花费了多少时间，从而给使用者优化和调试提供有效信息。如\ref{fig:dig1}所示，我们可以看到，每次执行一个函数之后，被分析程序调用Count()函数，事实上就是把计数器作加一的处理。Count()函数只是被动接受调用，然后对一个与被分析程序无关的计数器写入值，并没有影响到被分析程序本身，故而该方法可以进行并行化。

\begin{figure}[!htp]
  \centering
  \includegraphics[width=0.8\textwidth]{chap1/Dig1}
  \bicaption[fig:dig1]{函数计数的简单例子}{函数计数的简单例子}{Fig}{A simple example of method count}
\end{figure}

与此类似，很多其他的分析程序也可以进行并行化的处理。文献\cite{paSpeed}中指出，在串行执行的情况下，二进制动态程序分析可能会导致高达1000倍缓慢的速度。这是会很大程度上影响到被分析程序本身的。因此，将分析程序与被分析程序分离开来执行，理论上能提升动态分析的效率。

\section{已有解决方案}

Shadow profiling\cite{shaPro}是采用并行化进行程序分析的一个方案。不同于以往串行执行中直接一起执行分析程序与被分析程序，它创建了一个处理的线程，称为影子线程，专门用于处理和执行分析程序。由于利用了现代操作系统里基于拷贝的创建子进程操作，Shadow profiling中的处理线程可以认为是父线程（即被分析程序）的一个拷贝。但由于采用这种方式，各个线程之间是共享地址空间的，故而在程序安全方面不能得到保证。

Superpin\cite{superPin}则是另一个比较有名的动态并行程序分析框架，它采用了Pin作为动态注入的工具，在此基础上进行并行化的处理。与Shadow profiling不同的是，Superpin是将被分析程序以时间片为单位进行切分，通过其他线程来

% PiPA\cite{pipa}是一种现有的并行化程序分析的方案，它采用了DynamoRIO作为二进制动态代码插桩工具来生成并行代码
