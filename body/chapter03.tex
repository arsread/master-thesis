%%==================================================
%% chapter03.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% Encoding: UTF-8
%%==================================================

\chapter{Deferred Method框架}

Deferred Method是瑞士卢加诺大学动态程序分析小组所开发的一套并行程序分析的框架。通过使用该框架，用户能够方便地在比较高层面进行编程，从而在不需要关心底层代码的执行状况的情况下，编写出高效的并行程序。该框架采用ASM作为动态代码生成的工具，效率较高。本章将通过概览、简单示例、设计框架、处理策略等几个方面对Deferred Method进行描述，并对其一些功能进行讨论。

\section{概览}

在一些其他的并行程序分析工具中，被分析程序的颗粒度较粗，多数情况下这些被并行的任务也是重量级的，同时具有可以乱序执行，不影响原程序等特点，所以这些并行程序能很好地完成多线程处理这些并行任务的功能，效率上也比较高。但当被并行的任务颗粒度较细的时候，执行任务本身的开销并不大，并行线程并没有得到很好的利用；另一方面，当这些任务被执行的次数较为频繁的时候，轻量级的任务被调用多次，耗费在进程间通信的开销有时甚至要大于单线程执行被分析程序的开销。

为了解决这一问题，学术界提出了一些解决的方法，其中一个代表性的方法就是前文提到的基于缓存机制的处理方法。基于这个方法开发的工具一般都会维护一个或多个缓存（例如为每个线程维护一个线程本地的缓存），每个缓存用于存储程序运行时遇到需要并行的任务的相关信息，例如被调用的函数名字或者id，调用参数等等。并行的时候，主线程并不会立即把参数传递给处理线程，而是先缓存起来，等到缓存满的时候，再一并交给处理线程进行处理。与原来的简单并行相比，这种方法能很有效地减少进程间通信，原来需要多次通信的调用现在被缩减为一次；另一方面，由于处理线程每次都能拿到整个缓存的调用，当缓存设置合适的时候，处理线程能够保持一段时间的高负载工作，从而提高了CPU的利用率。

Deferred Method框架即是基于这个思想进行开发和改进的。它能比较有效率地处理一些颗粒度比较小的任务，同时提供了一套可定制的处理线程的策略，例如同步执行，即缓存中的内容即交由主线程处理；例如线程池策略，即维护一定数量的线程和一个任务队列，空闲的线程从任务队列中取得任务进行处理。

Deferred Method提供了一套高层次的、易用性高的接口。它通过使用ASM作为工具，自动从用户定义好的Java类中分析取得相关的信息，并生成相应的代码。缓存任务，提交给处理线程等细节被隐藏起来，用户只需要关注高层的实现，而不需关心这些代码在字节码层面上的实现。这套接口同时也允许用户对诸如缓存大小、队列长度进行设置。与其他框架相比，这个框架引入了一些功能：

\begin{itemize}
	\item 多种处理策略。该框架提出了如单线程同步处理、线程池处理、自适应线程处理等多种策略。用户可根据CPU资源的利用情况自行选择需要使用的处理策略。例如在单核程序中，可以使用同步处理的方式、在多核处理中，可以采用线程池或自适应处理的策略。
	\item 结果合并。该框架提供了一个处理器钩子，用户能够使用这个钩子作为接口，定义在每个缓存执行前后所需要执行的一些代码；并为每个缓存提供了一个本地的变量池。用户利用这个机制，可以在缓存被处理前定义本地变量用于储存该次处理的结果，而后在处理完成后，将本地的结果合并到全局的结果中。采用该方法的优点是能减少对全局变量的访问，从而减少多线程同步所带来的开销，能有效地提高效率。
	\item 代码自动生成。相关的代码是由程序自动分析生成的，省去了用户对底层代码和注入过程的关注。
\end{itemize}

以下将通过一个简单的示例来演示Deferred Method的功能。

\section{简单示例}

以下是一段简单的函数计数的代码：

\begin{lstlisting}[language=Java]
public static void foo(){
	//注入的分析代码，即对计数器的调用
	methodCount();
	//函数原代码
	……
}
\end{lstlisting}

在该代码段中
