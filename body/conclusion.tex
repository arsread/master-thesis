%%==================================================
%% conclusion.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% version: 0.3a
%% Encoding: UTF-8
%% last update: Dec 5th, 2010
%%==================================================

\chapter*{全文总结\markboth{全文总结}{}}
\addcontentsline{toc}{chapter}{全文总结}

随着计算机编程语言特性的发展，在程序分析领域，静态分析方法受到了越来越多的约束，动态分析的重要性越来越高。动态程序，顾名思义就是在执行程序的同时，对程序进行分析，以达到检测其中的bug、对其进行优化等等目的。相比于静态分析，动态分析能有效地减少分析时间，并能在不获得源代码的情况下开始进行分析。

然而在动态分析中，一些重量级的动态分析程序所产生的问题也对研究者提出了挑战。一方面，这些分析程序的运行开销较大，给原程序的执行带来了很大的影响，降低了原程序的执行效率；另一方面，由于分析程序是伴随着被分析程序的执行而执行的，其执行顺序、执行线程等都受到了限制，有些能进行并行或者乱序执行的方法没有得到优化，使得执行过程过于冗长。而计算机技术的提高，多核、多处理器计算机的出现和发展，给并行执行动态程序分析带来了可能。

相关研究发现，在影响效率的动态分析程序中，有一部分代码与方法并不会对原程序产生影响，这就意味着这些代码可以被剥离原程序进行并行执行，从而提高其效率，减少其执行时间。

但简单地对这些程序进行并行化可能会引入负面的影响。一方面，由于某一些动态程序的方法需要访问一些共用数据段，仅仅不采取策略而只是单纯地将这些程序分配给不同的核执行，可能会造成更多不必要的访问共享数据结构的开销，从而使总体效率不升反降。

一个有效的解决方案就是把需要并行执行的动态程序先放入缓存中，在累积到一定数量的方法时，将该缓存统一执行，这样一方面提高了数据的局部性，另一方面也减少了对共享数据结构频繁访问所产生的开销。

Deferred Method即是基于该思想的所开发的一个并行框架。相比于其他类似的基于缓存的框架，Deferred Method支持多线程、结果合并等功能，并为用户提供了一套比较高层次的编程接口，使得用户可以通过编写简单的代码即完成并行程序的编写。

本文在Deferred Method的结构上完善了其实现，并针对其不足提出了一些功能补充和性能优化。在功能补充上，主要有检查点的引入、影子线程的使用，允许并行带有返回值的方法等；在优化上，主要有锁同步方面的优化等。

检查点适用于带有比较粗颗粒度的任务时序逻辑的并行化，用户可在某些需要的程序点定义检查点，然后在之后检查或者等待该检查点的完成，通过这种方式实现并行方法之间的有序。

影子线程是一种针对单线程中并行方法有序执行的处理策略，通过对多线程程序中每个线程专门配备一个处理线程，以处理其缓存的方法。这些处理线程被称为影子线程。这个策略适用于多线程中每个单线程必须顺序执行，但多线程之间没有严格时序要求的情况。

锁同步方面，本文做了优化，通过在对程序上锁或者执行synchronized的监视器机制的时候，若遇到阻塞，则先执行当前的缓存的机制，保证了计算资源得到充分的利用，从而提高了效率。

带有返回值的情况允许被并行的方法返回带值的类，程序在之后需要使用该值的时候需要执行一套同步机制。

在实验中，这几个功能和优化都表现出了预期的执行结果，从而证明了它们能对Deferred Method以及现有的并行框架做出完善而有效的补充。通过使用改进后的框架，开发者能编写出更有效率的并行分析程序，从而使得程序分析的能处理更多的任务。
