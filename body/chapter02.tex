%%==================================================
%% chapter02.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% Encoding: UTF-8
%%==================================================

\chapter{相关工作}

本章主要分为两个部分。第一部分着重介绍了一些流行的代码注入的框架，第二部分介绍了通过并行化来进行程序分析的一些现有的工具。

这两个技术是本文所采用的解决方案的核心，相关工作也提供了很充分的支持。

\section{代码注入框架}
\subsection{动态二进制代码注入}
\subsubsection{Valgrind}

Valgrind\cite{valgrind}是一个用于建立动态代码分析工具的框架。它是由一系列的工具所组成，这些工具涵盖了调试，信息收集等功能。它默认的部分功能如下:

\begin{itemize}
	\item Memcheck.它能有效地检测出程序中的内存分配错误、栈溢出等故障，尤其对C和C++代码尤其有效。
	\item Cachegrind.它能收集和处理缓存和分支预测等信息，使程序的运行效率更高。
	\item Callgrind.它能收集调用图的信息和一些缓存的信息。
	\item Helgrind.它是一个线程错误侦测器，能侦测出多线程程序的错误，提高并行程序的正确性。
	\item DRD.它也是一个线程错误侦测器，但与Helgrind不同的是采用了其他的侦测技术，所以能侦测出不同的多线程错误。
	\item Massif.它是一个堆检测和优化器，能堆程序的堆使用进行检测，使程序使用更少的内存。
	\item DHAT.它是另一个堆检测和优化器，能提供程序块的生命周期，块使用情况和布局信息等。
\end{itemize}

Valgrind的工具是以插件的形式完成。工具的主要作用是以一定的规则处理Valgrind核型交付给它的代码。Valgrind使用了动态二进制重编译的方法来完成插桩。在执行过程中，首先编写好的工具被启动，然后将客户端程序即被分析程序加载进来，然后重编译客户端程序的二进制机器码。重编译后的代码被存储在一个代码缓存中，以便需要时能重新调出使用。

\subsubsection{DynamoRIO}

DynamoRIO\cite{dynamo}是一个建立在IA32架构上，并适用于Windows、Linux等操作系统的框架。与其他类似得到框架相比，它能够分析比较大的程序，例如一些大型的桌面程序。

目前动态二进制动态代码注入工具普遍采用虚拟机及二进制代码解释的方法。但这个方法存在一定的不足，如在解释的时候需要通过模拟器来执行，影响了运行的效率。DynamoRIO采用了一个方法来解决这个问题，即把注入后的代码进行缓存，以便下次使用的时候就能直接引用这些注入后的代码。

DynamoRIO拷贝基本块里的代码到代码缓存中，然后在本地进行执行。在每个基本块的最后程序的执行状态会被记录并返回给DynamoRIO，以便DynamoRIO进行上下文切换。

DynamoRIO维持了一些线程私有的代码缓存，每个缓存都指向了一个基本块缓存和一个轨迹缓存。研究表明在大多数多线程程序中，只有很少的一部分代码是被多个线程共同使用的，故而事实上为每个共享代码块在每个线程中维持缓存并保持同步更新是会增加其开销的。

\subsubsection{Pin}

Pin\cite{pin}是Intel开发的一个动态二进制代码的注入和修改系统。它基于一个注入引擎，并为用户提供了一整套完善丰富的接口。通过使用这套接口，用户能自定义一些注入方式和代码，这些以插件形式自定义的设置称为Pintools.Pintools支持多种指令集如IA-32,IA-65,ARM等，以及诸如Windows、Linux等操作系统。Pin能允许用户在程序的任何代码点中插入函数调用。它能够自动地识别寄存器，故而被插入的代码段的寄存器使用不会覆盖原程序的寄存器。

Pin，Pintools和原程序是在同一个地址空间上执行的。Pin使用了ptrace来控制原程序的运行，并相应地获得处理器的信息。然后Pin开始读取用户自定义的Pintools，分析并加载其中的相关信息，进行初始化。最后Pin开始解释/编译原程序的代码，编译出来的二进制代码就是加入了用户自定义的代码段的二进制代码。

Pin的组成包括了一个虚拟机系统和一个代码缓存系统。虚拟机系统里包括了一个即时编译器，一个模拟器和一个调度器.模拟器负责执行一些无法被直接执行的代码，例如需要被虚拟机特别处理的一些系统调用等。调度器负责决定下一段需要被即时编译器编译的代码段。

Pin采用了一些技术来提高效率，例如代码内嵌，寄存器重分配，存活变量分析，指令调度等，因而它的效率相对于其他的类似工具普遍能提高。如相对于Valgrind和DynamoRIO，在基本块计数这一任务中，Pin能够比Valgrind快3.3倍，比DynamoRIO快2倍。

\subsubsection{其他工具}

二进制动态注入在很多方面是与程序分析的其他领域类似的，例如动态优化和动态翻译系统。而在这两个领域也有很多有用的工具。

在动态优化领域比较有代表性的文献有\cite{mojo, continuous}等。

Mojo\cite{mojo}是微软研究院在x86架构上开发的一个动态代码优化工具。它主要有以下的特点:

\begin{itemize}
	\item 支持有异常处理机制的、多线程的大型桌面应用。
	\item 平台无关性，即不需要对操作系统有特别的要求。
	\item 与原程序相比，优化后的代码能有较高的执行效率。
	\item 程序具有灵活性，能与静态编译器的信息进行合并。
\end{itemize}

文献\cite{continuous}中所提出的工具则在给定的一些测试用例（如SPEC2000）上进行测试，通过分析运行时的信息，统计出各个部分运行所耗费的时间，从而计算出程序的瓶颈。通过这些收集到的瓶颈，该工具对瓶颈路径进行优化，在运行时对分支指令进行修改，从而达到优化代码的目的。

在动态翻译领域，也有很多相关的文献，如\cite{bt1, bt2, bt3, bt4}等。

IA-32 EL\cite{ia32}是一个在Intel IA-32架构上执行的动态二进制翻译技术。它具有以下特点：

\begin{itemize}
	\item 能在第一次翻译的时候获取动态信息，以便在第二次翻译的时候能够使用这些信息。
	\item 平台无关性。
	\item 具有异常处理机制。
\end{itemize}

Walkabout\cite{walkabout}是另一个动态二进制翻译系统，它具有重定位目标、便于实验、与具体执行机器分离的机器无关性，并具有调试功能。它是一个很好的二进制翻译实验的平台，可用于试验二进制翻译的相关技术、算法等等。

文献\cite{transmeta}则是在代码变形工具的基础上进行改进，使其称为一个有异常处理机制的、平台无关的、健壮的翻译系统。

文献\cite{accu}设计了一种二进制翻译系统，该系统是针对协同设计的虚拟机系统设计的，采用了相关硬件进行辅助的技术。

\subsection{Java语言中的代码注入工具}
\subsubsection{AspectJ}

AspectJ\cite{aspectJ}是Java上一个简单而实用的拓展。它采用了一个基于切点（joint point）的模型。切点是程序中需要被执行的点，它们是被切面标志所定义的程序点。最简单的切面标志即是显式的签名。其他的标志包括一个方法是否为公有方法、在某些特定的动态上下文下是否发生方法调用等。

\subsubsection{BCEL}

BCEL\cite{bcel}是一套字节码分析的工具。它既能用于静态字节码的分析，也能用于懂爱代码的生成与变换。它提供了一套比较高层次的抽象，从而允许用户在高层对代码进行操作，而不必去关心一些Java类文件的格式等。这套接口分为以下几个部分：

\begin{itemize}
	\item 一个对类文件的静态属性进行描述的包。该包能检查和描述类文件的类型，但不用于对字节码进行修改。这个包能正确地读取和写入类文件。这个包在没有Java原文件时对字节码的分析非常有用。
	\item 一个动态生成或者修改字节码的包。它能用于插入分析代码段，删除不需要的代码，或者作为Java编译器生成字节码的后端等等。
	\item 一些代码示例和工具。如把Java类文件转换成HTML文件的工具等。
\end{itemize}

\subsubsection{ASM}

ASM\cite{asm}是在功能上与BCEL类似的一个字节码分析工具，它也能完成字节码的读取、修改、写入等功能。它采用了Visitor的设计模式，不使用对象来表示被访问的语法树，而使得工具在规模和效率上比较高。ASM的特点如下：

\begin{itemize}
	\item 占用空间小，分析效率高。
	\item 能够优化执行次数较多的代码，使运行速度得到提升。
	\item 提供了全面、丰富的字节码处理方法。
\end{itemize}

本文所使用的框架采用了字节码动态生成的方案，即是基于ASM的。

\section{并行程序分析的发展情况}
\subsection{Shadow Profiling和Superpin}

Shadow Profiling\cite{shaPro}和SuperPin\cite{superPin}都是基于切片的并行分析。它们通过提前对线程进行拷贝创建，从而使得被拷贝出来的线程能够执行带有分析代码的程序，而主线程依旧保持未加入分析程序的状态。通过这种方法，主线程能够与分析程序分离开，从而达到了并行的效果。这两个框架都是基于动态二进制代码进行注入的，而它们的局限性在于只能支持单线程的应用。这种局限性使得它们在处理一些具有多线程的库的时候，只能创建当前线程的拷贝，而无法对其他线程执行相关的操作。

\subsection{PiPA}

PiPA\cite{pipa}则采取了结合流水线与程序分析的方法，将流水线技术应用到多线程中。分析数据被收集起来，存放于线程本地的缓存中，当缓存满时，这些数据即被交付予处理线程，处理线程通过流水线对其进行相关的处理。PiPa的一个不足之处在于它本身是基于二进制代码的注入，因而并没有提供一个高层的接口给用户使用，在易用性上有局限性。另外，它同时也不支持结果的合并等功能。

\subsection{CAB}

CAB\cite{CAB}是一个基于无锁环形缓存的动态分析框架。它采用了缓存机制作为被分析程序与分析程序进行数据交换和沟通的手段。这个框架的实现是在Java虚拟机的层面上完成的，它有效地使用了多核系统里的共享缓存的结构，从而提高了效率。然而这个框架在缓存设置以及多线程的策略处理上存在不足，同时它并不支持结果合并等功能的高层代码的实现。

\subsection{Buffered advice}

Buffered advice\cite{bfad}在AspectJ的基础上做了改进。它能允许AspectJ的通知使用一些特殊的注解，从而允许相关代码的异步执行。调用方法所采取和使用的参数被储存在一个线程本地的缓存中，当缓存满时，这些方法的调用将被交付执行。这个工具的局限性在于这些注解是需要被AspectJ的接口所限制的，并且它需要一个自定义的编译器，同时它并不支持如结果合并等的功能。

\subsection{另一个采取缓存的并行工具}

在文献\cite{paSpeed}中，作者介绍了一个同样采取缓存机制的并行框架。这个框架同样是基于动态二进制代码注入技术，为每个线程维护了一个线程本地的缓存，通过缓存的机制提高并行的速度。这个工具也提供了一个高层的接口，用户通过使用这个高层接口，能有效地生成代码，生成的代码用于填充及提交缓存。但这个框架同样没有合并结果等功能，并且缺乏自适应的一些多线程处理的策略。

\subsection{HeapMon}

HeapMon\cite{heapmon}相比于前面的几种框架，采用了多一个辅助线程来管理和监控堆上的每个字单位上的状态变化。它能侦测出内存错误，诸如对未经初始化或者未经分配的内存地址进行读取的操作。HeapMon的缓存机制不会带来很大的开销，这是由于它采用了硬件辅助的方式进行缓存的存储。区别于其他工具，它是一个专门用于内存运行时监控的程序，采用了诸如为缓存的每个字单位加一个状态位，保持应用的线程与辅助线程之间的通信，为辅助线程维护一个私有的缓存等方法来实现和优化代码的注入。

\subsection{ParCCT}

ParCCT\cite{parcct1, parcct2}是用于并行收集调用内容树的信息以及多核上程序运行的一个技术。每个线程都维护了一个影子堆栈，生成函数调用的包，把这些包的相关信息合并到整棵树中。这也是一个只专门用于特定功能的工具，但其中的一些设计思路可以被拓展到其他应用中。

\section{本章小结}

本章分别介绍了动态代码注入技术和并行程序分析技术的一些框架和工具,并比较了他们的优劣。这两种技术是本文所采用的方法的核心技术，其中动态代码注入技术又着重介绍了几个Java平台上的技术，本文也将采取其中的ASM框架。在并行程序分析方面，本章也分析了其中几个框架，借鉴了其中使用缓存的思想，并分析了它们一些局限性和不足的功能。
