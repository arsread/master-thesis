%%==================================================
%% chapter03.tex for SJTU Master Thesis
%% based on CASthesis
%% modified by wei.jianwen@gmail.com
%% Encoding: UTF-8
%%==================================================

\chapter{Java并行框架的功能优化实现}

前文介绍了Deferred Method并行框架。该框架提供了一套易用性高的接口给用户，允许用户在高层次上实现一套自己的代码注入方案。但该方案事实上仍存在着一些不足，例如：

\begin{itemize}
	\item 时序的问题。由于同步处理的方法是单线程执行，故而时序上是可以得到保证的，但这种方法并不是严格并行的；采用基于线程池的异步处理策略和自适应的策略保证了多线程的并行性，但在时序上会产生问题。
	\item 处理策略的问题。该框架只提供了三种策略，这三个策略只是给予用户通过简单地从可用核心的数量上来区分和决定需要使用的策略的选择的，而没有其他的处理策略能通过其他的情况来考虑，例如通过原程序的线程使用情况。
	\item 提交缓存的问题。该框架只有在缓存满的情况下才会自动提交缓存，但事实上有的时候会出现一些情况，使得缓存长时间无法被填满，此时缓存中所储存的方法无法被及时地处理，浪费了空闲的计算资源。
	\item 返回值的问题。该框架只能处理没有返回值的方法，有些分析程序需要在特定的时候使用到之前的分析程序的分析结果，这在Deferred Method默认提供的接口里是无法实现的。
\end{itemize}
		
本章将针对这些问题，一一进行阐述，并提出解决方案和设计。

\section{时序问题和检查点（CheckPoint）的使用}

\subsection{概述}

在前文所列举的方法计数的例子中，由于计数器对原程序的执行并没有时序要求，所以分析程序可以乱序执行；但在一些程序分析的例子里，却存在着时序的约束。一个例子是内容调用树的创建。分析程序需要对树进行初始化，然后才开始整棵树的构建的。但在Deferred Method里所提供的几种处理策略里面，却只有同步处理的方法能保证时序。

一个解决方法是给缓存里的每一个方法加入时间戳。储存的时候，把调用顺序的信息也加入其中，这样可以使得部分需要的方法能有序执行。但这种方法一方面为每个方法都加入了调用信息，使得信息太过详细，可能会引入很多不必要的时序，一定程度上也破坏了程序的并行性；另一方面也加大了程序的开销。

在保证最大程度的并行化地情况下尽可能简单、低开销地加入保证时序的系统，本文提出了检查点（CheckPoint）的技术。

\subsection{设计}

检查点（CheckPoint）的设计思想是在原程序中加入一些点作为标记，在该点以前的所有缓存即可以作为该检查点所标记的缓存。对检查点所标记的缓存，检查点机制能提供两个接口：

\begin{lstlisting}[language=Java]
public interface ProcessingCheckPoint {

	public boolean isProcessed();

	public void awaitProcessed() throws InterruptedException;

}
\end{lstlisting}

其中isProcessed()方法返回一个布尔值，用以表示该检查点所标记的所有缓存是否已经处理完成；awaitProcessed()方法则是用以等待所标记的缓存执行完成，如果在调用方法时缓存尚未处理完成，则该进程会陷入阻塞。

检查点的创建方法则是在DeferredEnv环境中加入相关的方法：

\begin{lstlisting}[language=Java]
	public ProcessingCheckPoint createCheckPoint();
\end{lstlisting}

该方法返回一个检查点的类型的实例，用户可以在这之后使用该实例对程序的时序进行处理。

\subsection{实现}

检查点机制的实现借用了之前的时间戳的方式，但在实现上比之轻量，能够引入较少的开销。

首先，对于每个线程，每次创建的缓存都会被指定一个相对于该线程唯一的编号。该机制另外维护了一个哈希表，每个表项的索引是被分析程序的线程，而每个线程所索引的值都指向一个优先队列。该优先队列存储的是目前已经被处理完成的缓存。

其次，对于每个线程，该实现会创建一个计数器，用以标记从开始的第一个缓存（例如将其编号设置为1）起所已经被处理好的连续的缓存。例如缓存1至3以及5都被处理好了，而4没有被处理好，此时的计数器应为3.

将这两个设定结合起来，即可以完成检查点的机制。当缓存被执行完成的时候，处理器会将该缓存的编号通知给DeferredEnv环境，环境即开始通过该编号与计数器和优先队列进行比对，然后对计数器和优先队列的信息进行更新。如在上例中，当缓存4被处理完成后，该编号信息被提交，环境先将其与计数器进行比对，将计数器更新至4，然后更搜索优先队列，将计数器更新至5，并将5从优先队列中出队。由于优先队列是以最小堆的数据结构实现的，所以在检索上具有效率优势。

检查点在创建的时候，其中也会加入当前缓存的编号信息，所以isProcessed()执行的时候，是将检查点的编号与当前计数器的编号进行比对，以确定在该检查点之前的缓存是否已经都被处理完成。

awaitProcessed()方法的实现则稍微复杂一点，采用了Java中的wait()和notify()的方法。当需要等待时，wait()方法被调用，线程陷入阻塞状态，等待处理的完成。环境另外维护了一个数据结构，用以存储所创建的检查点。由于检查点在每个线程里面总是按缓存顺序创建的，故而并不需要进行排序，简单地使用链表的方式进行储存即可。当缓存被处理完成时，环境更新计数器，然后开始从链表中依次取出检查点进行比对，如果发现某些检查点所标记的所有缓存已经被执行完毕，环境即向相关的线程发出唤醒的请求，以让被阻塞的线程继续执行。

需要注意的是，由于检查点的创建是以缓存为单位的，故而在创建检查点的时候，不管当前线程的缓存是否已满，该缓存都必须被处理。由此可以预见到的一点是，当检查点被频繁创建的时候，线程经常需要提交未满的缓存给处理线程进行处理，从而使得缓存无法发挥其预期的最大效用，会带来效率上的降低。

\section{影子线程的引入及使用}

\subsection{概述}

Deferred Method框架默认提供了几种并行处理的机制，如同步处理、基于线程池的异步处理等等。用户可以针对空闲计算资源的多少确定使用的处理机制。如在单核的情况下，可以使用同步处理的机制；在比较固定的数量的核心能够保持长时间的空闲的情况下，可以采用基于线程池的异步处理策略；在系统资源可用性波动比较大的情况下，可以采用自适应的处理机制。

然而一个不足是这几个处理机制都是针对CPU使用状况来定制的，用户只能根据CPU的使用状况来决定使用哪种机制。而在实际应用中，会出现其他的情况。例如有些程序的线程使用是动态的，它们能根据CPU的核心数来决定使用多少线程，或者在运行时动态增减线程的数量。这时如果采用同步或者线程池的方法，很容易就会出现资源分配过剩或者不足的情况；自适应的方法能解决这种问题，但在线程数变化太频繁的情况下，这个策略的反应速度并不能很快跟上原程序的变化。

一个解决的方案就是不再根据CPU的使用资源的使用情况来决定使用的线程数，而是通过原程序的线程使用情况来决定处理线程的数量。例如我们可以为原程序的每个线程固定地分配一个处理线程，从而使得处理线程可以随着原程序线程数同时动态变化。基于该想法，本文提出了影子线程的概念。

\subsection{设计}

影子线程的创建接口被设计为以下的形式：

\begin{lstlisting}[language=Java]
public ShadowThreadProc(int queueCapacity);

public ShadowThreadProc() {
	this(DEFAULT_QUEUE_CAPACITY);

}
\end{lstlisting}

它提供了两个默认的构造方法：在不传予参数时，构造方法将采用默认的值作为队列的长度。影子线程的使用和其他处理策略一样，都是采用createDeferredExecution中传递参数的方法。

在程序启动时，影子线程处理部分是没有处理线程存在的，当缓存被提交时候，影子线程会获取提交该缓存的线程的信息，检索该信息的处理线程是否存在：如果存在的话，则获取该处理线程及相关的队列；如果不存在，则创造一个相关的处理线程进行处理。处理的机制同线程池相似，都是采用阻塞队列进行实现，这时的队列不像其他的几个策略一样只有一个，而是为每个原程序的线程都维持一个队列；每个处理线程只需要处理自己所对应的原线程的队列。在这种实现下，每个线程的任务得到了分离，在一些任务分配比较特殊的程序里，能即时地反应出系统资源的占用情况。

在原程序的线程结束的时候，影子线程也应该相应地结束，以释放被占用的资源，同时保证一个原程序线程对应一个处理线程的形式。

\subsection{实现}

影子线程的实现与其他的几个策略相比，主要有两个注意点。

\subsubsection{线程索引表}

在影子线程中，一个索引表被维护，该表的索引为原程序的线程，每个索引都指向一个独立的处理线程。缓存类的代码被改写，其中通过字节码加入了一个handInThread()的方法，该方法获取执行该方法的线程，即属于该缓存的线程的引用，并将其提交给处理线程的分配程序。在收到这个引用的时候，分配程序索引哈希表，取得这个线程的引用所对应的处理线程；当没有处理线程的时候，说明该线程是第一次提交缓存，分配程序会为其初始化一个处理线程，并为该线程分配一个队列。其中关键的代码如下：

\begin{lstlisting}[language=Java]
public void process(Buffer buffer) {
	if (isRunning.get()) { // some buffers might be processed after the
		// status is set to !isRunning
		Thread thread = buffer.handInThread();
		BlockingQueue<Runnable> workQueue = getQueue(thread);
		forceSubmission(workQueue, buffer);
	}
}

private BlockingQueue<Runnable> getQueue(Thread thread) {
	BlockingQueue<Runnable> queue;
	synchronized (threadWorkerMap) {
		WorkerThread worker = threadWorkerMap.get(thread);
		if (worker == null) {
			queue = registerNewThread(thread);

		} else {
			queue = worker.getQueue();

		}
		return queue;

	}

}
\end{lstlisting}

其中，process(...)方法完成了取得对应的处理线程，并将缓存加入队列的过程；另一方面getQueue(...)方法则完成了检测处理线程是否存在，在其不存在的情况下进行初始化，并取得这个处理线程的队列的过程。

\subsubsection{影子线程结束的处理}

影子线程被设置为守护线程。在Java中，当运行在虚拟机上的所有进程都是守护进程的时候，这些守护进程会停止执行。另一方面，由于影子线程是跟随原程序线程启动和终止的，故而当原程序的线程终止时，其相应的线程也将同时终止。

在本文中使用了jvmti来完成这一过程。jvmti
